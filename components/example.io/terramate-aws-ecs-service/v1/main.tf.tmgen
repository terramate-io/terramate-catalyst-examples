# Initial deployment trigger to postpone evaluation of remote data sources
resource "null_resource" "initial_deployment_trigger" {
}

# Look up ECS cluster by name (ECS clusters don't support tag filtering)
data "aws_ecs_cluster" "cluster_by_name" {
  cluster_name = component.input.cluster_name.value

  depends_on = [
    null_resource.initial_deployment_trigger
  ]
}

# Look up VPC via AWS data sources by tags
data "aws_vpc" "vpc_by_tags" {
  dynamic "filter" {
    for_each = component.input.vpc_filter_tags.value
    content {
      name   = "tag:${filter.key}"
      values = [filter.value]
    }
  }

  depends_on = [
    null_resource.initial_deployment_trigger
  ]
}

# Get private subnets in the VPC (ECS tasks should be in private subnets)
# Filter by Name tag pattern that includes "-private-" which is how terraform-aws-modules/vpc tags private subnets
data "aws_subnets" "private" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.vpc_by_tags.id]
  }

  filter {
    name   = "tag:Name"
    values = ["*-private-*"]
  }
}

locals {
  # Use AWS data sources to find cluster, VPC and subnets
  cluster_arn_value = data.aws_ecs_cluster.cluster_by_name.arn
  vpc_id_value      = data.aws_vpc.vpc_by_tags.id
  # Use private subnets only (ECS tasks should not be directly exposed to internet)
  subnet_ids_value = data.aws_subnets.private.ids

  # Look up ALB if alb_filter_tags is provided
  # Use the ALB's security_groups attribute to get the security group ID directly
  # This avoids the issue of multiple security groups matching the same bundle UUID tag
  # Note: security_groups is a set, so we convert it to a list and take the first element
  alb_security_group_id_value = component.input.alb_filter_tags.value != null ? tolist(data.aws_lb.alb_by_tags[0].security_groups)[0] : null
  target_group_arn_value      = component.input.alb_filter_tags.value != null ? aws_lb_target_group.alb_target_group[0].arn : null
}

# Look up ALB by tags
data "aws_lb" "alb_by_tags" {
  count = component.input.alb_filter_tags.value != null ? 1 : 0

  tags = component.input.alb_filter_tags.value

  depends_on = [
    null_resource.initial_deployment_trigger
  ]
}

# Create target group for the ECS service
# Note: The ALB bundle doesn't create target groups by default, so we create it here
resource "aws_lb_target_group" "alb_target_group" {
  count = component.input.alb_filter_tags.value != null ? 1 : 0

  name_prefix = "${substr("${replace("${data.aws_lb.alb_by_tags[0].name}-${component.input.target_group_key.value}", "-", "")}", 0, 6)}"
  port        = component.input.container_port.value
  protocol    = "HTTP"
  vpc_id      = local.vpc_id_value

  target_type = "ip"

  health_check {
    enabled             = true
    healthy_threshold   = 2
    interval            = 30
    matcher             = "200"
    path                = "/"
    port                = "traffic-port"
    protocol            = "HTTP"
    timeout             = 5
    unhealthy_threshold = 2
  }

  deregistration_delay = 30

  tags = merge(
    component.input.tags.value,
    {
      Name = "${data.aws_lb.alb_by_tags[0].name}-${component.input.target_group_key.value}"
    }
  )

  lifecycle {
    create_before_destroy = true
  }

  depends_on = [
    null_resource.initial_deployment_trigger,
    data.aws_lb.alb_by_tags
  ]
}

# Attach target group to ALB listener
# Note: The ALB bundle creates a default HTTP listener on port 80
data "aws_lb_listener" "http" {
  count = component.input.alb_filter_tags.value != null ? 1 : 0

  load_balancer_arn = data.aws_lb.alb_by_tags[0].arn
  port              = 80

  depends_on = [
    null_resource.initial_deployment_trigger
  ]
}

resource "aws_lb_listener_rule" "target_group" {
  count = component.input.alb_filter_tags.value != null ? 1 : 0

  listener_arn = data.aws_lb_listener.http[0].arn
  priority     = 100

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.alb_target_group[0].arn
  }

  condition {
    path_pattern {
      values = ["/*"]
    }
  }

  depends_on = [
    aws_lb_target_group.alb_target_group,
    data.aws_lb_listener.http
  ]
}

module "ecs_service" {
  source  = "terraform-aws-modules/ecs/aws//modules/service"
  version = "6.1.0"

  name        = component.input.name.value
  cluster_arn = local.cluster_arn_value

  cpu    = component.input.cpu.value
  memory = component.input.memory.value

  # Enables ECS Exec
  enable_execute_command = component.input.enable_execute_command.value

  # Assign public IP for Fargate tasks (required for pulling images from public registries)
  assign_public_ip = component.input.assign_public_ip.value

  # Blue/green deployment configuration
  deployment_configuration = component.input.deployment_configuration.value

  # Container definition(s)
  container_definitions = component.input.container_definitions.value

  # Service Connect configuration
  service_connect_configuration = component.input.service_connect_configuration.value

  # Load balancer configuration
  load_balancer = local.target_group_arn_value != null ? {
    service = {
      target_group_arn = local.target_group_arn_value
      container_name   = component.input.container_name.value
      container_port   = component.input.container_port.value
    }
  } : null

  subnet_ids = local.subnet_ids_value

  # Security group rules - add ALB security group ingress if alb_bundle_uuid is provided
  security_group_ingress_rules = merge(
    component.input.security_group_ingress_rules.value,
    local.alb_security_group_id_value != null ? {
      alb = {
        description                  = "Service port"
        from_port                    = component.input.container_port.value
        ip_protocol                  = "tcp"
        referenced_security_group_id = local.alb_security_group_id_value
      }
    } : {}
  )
  security_group_egress_rules = component.input.security_group_egress_rules.value

  service_tags = component.input.service_tags.value
  tags         = component.input.tags.value
}
